+++
title = "Rust 函数返回值书写问题"
description = ""
date = 2018-08-05T23:53:16+08:00
author = "Lin Yinfeng"
draft = true
[taxonomies]
categories = ["笔记"]
tags = ["rust", "类型系统"]
[extra]
+++

Rust 的类型系统是特别的。它的许多设计令我在使用之初感到疑惑，在使用了一段时间以后才领悟到它设计的目的。而在几周学习尝试 Rust 的过程中，这个类型系统令我感到最大的一个困惑就是函数返回值问题。这篇笔记将记录我的思考。

<!-- more -->

# Rust 类型推理（Type inference）范围

初学 Rust 很可能遇到的一点疑惑就是：既然 Rust 的类型推理能力不弱，为什么甚至不能像在 C++ 中一样肆意书写 auto，尤其是在函数返回值中？

这主要是因为 Rust 做出的与一个设计决策：仅有局部类型推理，没有全局类型推理。所有非局部的名字的类型都是显式给出的。包括声明的函数（静态生命周期），静态变量，类型声明等。与此相反，局部变量，闭包等类型都是可以推出的。

这样做的好处是，无法使类型推导超越函数的边界，大大减轻了编译器定位错误的负担。使 Rust 编译器不容易像 C++ 编译器一样，因为某一个地方的小类型错误输出过深的报错信息。当然，这也限制了程序的表达能力，尤其是 Unboxed closure 加入后，闭包本身不携带函数指针，依赖编译期生成的唯一类型直接 impl 不同的 Fn trait 以提升效率，这使得 Rust 中的闭包的类型是无法书写的，造成在跨越边界的时候出现问题。

# 泛型类型参数（Generic Type Parameters）
